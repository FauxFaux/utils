#!/usr/bin/perl -w

#=======================================================================
# $Id$
# Converts between various GPS formats
#
# Character set: UTF-8
# ©opyleft 2002– Øyvind A. Holm <sunny@sunbase.org>
# License: GNU General Public License, see end of file for legal stuff.
#=======================================================================

use strict;
use Getopt::Long;
use Time::Local qw { timegm_nocheck };

$| = 1;

our $Debug = 0;

our %Opt = (
    'comment-out-dups' => 0,
    'create-breaks'    => 0,
    'debug'            => 0,
    'double-y-scale'   => 0,
    'epoch'            => 0,
    'help'             => 0,
    'output-format'    => "",
    'short-date'       => 0,
    'skip-dups'        => 0,
    'strip-whitespace' => 0,
    'undefined'        => "",
    'use-comma'        => 0,
    'xml'              => 0
);

our $progname = $0;
$progname =~ s#^.*/(.*?)$#$1#;

my $rcs_id = '$Id$';
my $id_date = $rcs_id;
$id_date =~ s/^.*?\d+ (\d\d\d\d-.*?\d\d:\d\d:\d\d\S+).*/$1/;

Getopt::Long::Configure("bundling");
GetOptions(
    "comment-out-dups|u" => \$Opt{'comment-out-dups'},
    "create-breaks|t"    => \$Opt{'create-breaks'},
    "debug"              => \$Opt{'debug'},
    "double-y-scale|y"   => \$Opt{'double-y-scale'},
    "epoch|e"            => \$Opt{'epoch'},
    "help|h"             => \$Opt{'help'},
    "output-format|o=s"  => \$Opt{'output-format'},
    "short-date|s"       => \$Opt{'short-date'},
    "skip-dups|d"        => \$Opt{'skip-dups'},
    "strip-whitespace|w" => \$Opt{'strip-whitespace'},
    "undefined|n=s"      => \$Opt{'undefined'},
    "use-comma|c"        => \$Opt{'use-comma'},
    "verbose|v"          => \$Opt{'verbose'},
    "xml|x"              => \$Opt{'xml'}
) || die("$progname: Option error. Use -h for help.\n");

my $PAUSE_LIMIT = 2 * 60; # Antall sekunder mellom to punkter det må til før en move legges inn.
my $Des = $Opt{'use-comma'} ? "," : ".";
my $Udef = "?";
my $Spc = $Opt{'strip-whitespace'} ? "" : " ";
my $in_dupskip = 0; # Er 1 hvis vi holder på med ignorering av duplikater
my $found_move = 0; # Settes til 1 hvis en /^# move$/ blir funnet.
my $first_time = 0;
my $last_time = 0;
my ($last_lon, $last_lat, $last_alt, $last_line) =
   (     1000,      1000,    100000,         ""); # Vi kan jo teoretisk sett være i Greenwich eller på ekvator

$Opt{'debug'} && ($Debug = 1);
$Opt{'help'} && usage(0);

# To avoid printing out extra "/> at the start of svg output:
my $svg_start_thing = "";

length($Opt{'undefined'}) && ($Udef = $Opt{'undefined'});
# Kunne vært et eget script på grunn av at det gjør sine helt egne 
# greier, men like greit å samle det på en plass.
# FIXME: Fjerner ikke første duplikatentryen.
# FIXME: Se om det går å få flytta den inn i print_entry() så man 
# slipper å ha to gptrans_conv’er i pipen.
# FIXME: Legg inn alle formatene.
if ($Opt{'comment-out-dups'}) {
    # Comment out areas without reception {{{
    my ($start_date, $end_date, $found_dup) = ("", "", 0);
    my @Dup = ();
    while (<>) {
        if (m#^1 (\S+) (\S+) (\S+) (\S+) (\d\d)/(\d\d)/(\d\d\d\d) (\d\d):(\d\d):(\d\d)#) {
            # {{{
            my ($lat_val, $lon_val, $Speed, $Unkn, $Month, $Day, $Year, $Hour, $Min, $Sec) =
               (      $1,       $2,     $3,    $4,     $5,   $6,    $7,    $8,   $9,  $10);
            if (($lat_val eq $last_lat) && ($lon_val eq $last_lon)) {
                unless ($found_dup) {
                    $start_date = "$Year$Month${Day}T$Hour$Min$Sec";
                    @Dup = ();
                    $found_dup = 1;
                }
                push(@Dup, "# $_");
                $end_date = "$Year$Month${Day}T$Hour$Min$Sec";
            } else {
                if ($found_dup) {
                    print("# $start_date-$end_date: CO: No signal \x7B\x7B\x7B\n");
                    for (@Dup) {
                        print($_);
                    }
                    print("# $start_date-$end_date: CO: No signal \x7D\x7D\x7D\n# move\n$_");
                    $found_dup = 0;
                } else {
                    print($_);
                }
            }
            $last_lat = $lat_val;
            $last_lon = $lon_val;
            # }}}
        } else {
            if ($found_dup) {
                push(@Dup, $_);
            } else {
                print($_);
            }
        }
    }
    if ($found_dup) {
        print("# $start_date-$end_date: CO: No signal \x7B\x7B\x7B\n");
        for (@Dup) {
            print($_);
        }
        print("# $start_date-$end_date: CO: No signal \x7D\x7D\x7D\n# move\n");
        $found_dup = 0;
    }
    exit(0);
    # }}}
}

# Print possible header {{{
if ($Opt{'output-format'} eq "gpstrans") {
    print("Format: DMS  UTC Offset:   0.00 hrs  Datum[100]: WGS 84\n");
} elsif ($Opt{'output-format'} eq "gpx") {
    print(<<END);
<?xml version="1.0" standalone="no"?>
<gpx>
$Spc$Spc<trk>
$Spc$Spc$Spc$Spc<trkseg>
END
} elsif ($Opt{'output-format'} eq "ps") {
    print(ps_header(532, 6034, 533, 6040));
    print("*u\n");
} elsif ($Opt{'output-format'} eq "xml") {
    print(<<END);
<?xml version="1.0" encoding="UTF-8"?>
<gpslog>
END
} elsif ($Opt{'output-format'} eq "svg") {
    print(<<END);
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
$Spc$Spc"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg height="1000" width="1000" viewBox="23 70 2 2"
$Spc${Spc}xmlns="http://www.w3.org/2000/svg" version="1.1">
$Spc$Spc<title></title>
$Spc$Spc<desc></desc>
END
}
# }}}

while (<>) {
    # Scan through stdin or specified files and send every GPS entry to 
    # print_entry()
    # {{{
    my $bck_line = $_;
    if (/^<\?xml\b/) {
        my $xml_data = $_;
        $xml_data .= join("", <>);
        read_xmlfile($xml_data);
        last;
    } elsif (/^# Pause: /) {
    } elsif (/^# move$/) {
        $found_move = 1;
    } elsif (/^#/) {
        print unless ($Opt{'output-format'} =~ /^(clean|xgraph|gpstrans|gpx|svg|xml|ygraph)$/);
    } elsif (m#^(\d+)\t([0-9\.\-,?]+)\t([0-9\.\-,?]+)\t([+\-\d?])#) {
        # Author’s format, epoch style {{{
        my ($ep_time, $lon_val, $lat_val, $Alt) =
           (      $1,       $2,       $3,   $4);
        my ($Sec, $Min, $Hour, $Day, $Month, $Year, $Wday, $Yday) = gmtime($ep_time);
        $Month++; # Urgh Ⅰ
        $Year += 1900; # Urgh Ⅱ
        print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $lon_val, $lat_val, $Alt);
        # }}}
    } elsif (m#^(\d\d\d\d)-?(\d\d)-?(\d\d)[T ](\d\d):?(\d\d):?(\d\d)Z?\t([0-9\.\-,?]+)\t([0-9\.\-,?]+)\t([+\-\d?])#) {
        # Author’s format, human-readable date format {{{
        my ($Year, $Month, $Day, $Hour, $Min, $Sec, $lon_val, $lat_val, $Alt) =
           (   $1,     $2,   $3,    $4,   $5,   $6,       $7,       $8,   $9);
        print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $lon_val, $lat_val, $Udef);
        # }}}
    } elsif (
        # Trackpoint\tN60.41630 E5.31675\t09.02.2006 20:24:37 (UTC)\t13.6 m\t\t93.9 m\t00:00:06\t56 kph\t123° true {{{
        #
        # Trackpoint\t
        # N60.41630 E5.31675\t
        # 09.02.2006 20:24:37 (UTC)\t
        # 13.6 m\t
        # \t
        # 93.9 m\t
        # 00:00:06\t
        # 56 kph\t
        # 123° true
        m{
            # Regexp {{{
            ^Trackpoint \t # Marker
            (N|S) ([\d\.]+?) \s (W|E) ([\d\.]+?) \t # Position (1-4)
            (\d+?) \. (\d+?) \. (\d+?) \s
            (\d+?) : (\d+?) : (\d+?) \s \( (.+?) \) \t # Time (5-11)
            ([\-\d\.]*?) \s? (.*?) \t # Altitude (12-13)
            ([\-\d\.]*?) \s? (.*?) \t # Depth (14-15)
            ([\d\.\-]*?) \s? (.*?) \t # Leg length (16-17)
            (\d\d) : (\d\d) : (\d\d) \t # Leg time (18-20)
            ([\-\d\.]+?) \s (.*?) \t # Leg speed (21-22)
            (.*?) # Leg Course (23)
            # }}}
        }x
    ) {
        my ($NS, $Y_deg, $WE, $X_deg) =
           ( $1,     $2,  $3,     $4); # Position
        my ($Day, $Month, $Year, $Hour, $Min, $Sec, $TZone) =
           (  $5,     $6,    $7,    $8,   $9,  $10,    $11); # Time
        my ($Alt, $Alt_unit) =
           ( $12,       $13); # Altitude
        my ($Depth, $Depth_unit) =
           (   $14,         $15); # Depth
        my ($Leglength, $Leglength_unit) =
           (        $16,            $17);
        my ($Legtime_hour, $Legtime_min, $Legtime_sec) =
           (          $18,          $19,          $20);
        my ($Legspeed, $Legspeed_unit) =
           (      $21,            $22);
        my ($Legcourse) =
           (       $23);
        ($NS eq "S") && ($Y_deg = 0-$Y_deg);
        ($WE eq "W") && ($X_deg = 0-$X_deg);
        print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $X_deg, $Y_deg, $Alt);
        # }}}
    } elsif (m#^T\t(\d\d)/(\d\d)/(\d\d\d\d) (\d\d):(\d\d):(\d\d)\t(.+)\xB0(.+)'(.+)"\t(.+)\xB0(.+)'(.+)"#) {
        # T 09/01/2002 11:51:26 60°23'36.3" 5°19'35.9" {{{
        my ($Month, $Day, $Year, $Hour, $Min, $Sec, $lat_d, $lat_m, $lat_s, $lon_d, $lon_m, $lon_s) =
           (    $1,   $2,    $3,    $4,   $5,   $6,     $7,     $8,     $9,    $10,    $11,    $12);
        my $lat_val = sprintf("%.5f", 1*($lat_d+($lat_m/60)+($lat_s/3600)));
        my $lon_val = sprintf("%.5f", $lon_d+($lon_m/60)+($lon_s/3600));
        print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $lon_val, $lat_val, $Udef);
        # }}}
    } elsif (m#^1 (\S+) (\S+) (\S+) (\S+) (\d\d)/(\d\d)/(\d\d\d\d) (\d\d):(\d\d):(\d\d)#) {
        # 1 60.3938222 5.3238754 17.3 0 09/01/2002 14:18:23 {{{
        my ($lat_val, $lon_val, $Speed, $Unkn, $Month, $Day, $Year, $Hour, $Min, $Sec) =
           (      $1,       $2,     $3,    $4,     $5,   $6,    $7,    $8,   $9,  $10);
        print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $lon_val, $lat_val, $Udef);
        # }}}
    } elsif (/^
        # @020721221336N6048353E00701826S015-00001E4859N1673U0000 {{{
            # Regexp {{{
            (@) # @
            (\d\d) # Year
            (\d\d) # Month
            (\d\d) # Day
            (\d\d) # Hours
            (\d\d) # Minutes
            (\d\d) # Seconds
            ([NS]) # N|S
            (\d\d) # Latitude degree
            (\d\d) # Latitude minute
            (\d\d\d) # Latitude minute decimals
            ([EW]) # E|W
            (\d\d\d) # Longitude degree
            (\d\d) # Longitude minute
            (\d\d\d) # Longitude minute degree
            (....) # Accurancy
            (......) # Altitude
            (...............)
            $
            # }}}
            /x) {
        my ($Alfa,   $Year, $Month, $Day, $Hour, $Min, $Sec, $NS, $Y_deg, $Y_degmin, $Y_mindec, $EW, $X_deg, $X_degmin, $X_mindec, $Accur, $Alt, $Rest) =
           (   $1, $2+2000,     $3,   $4,    $5,   $6,   $7,  $8,     $9,       $10,       $11, $12,    $13,       $14,       $15,    $16,  $17,   $18);
        my $ep_time = timegm_nocheck($Sec, $Min, $Hour, $Day, $Month-1, $Year);
        $last_time = $ep_time;
        my $tmp_x = sprintf("%.5f", $X_deg + $X_degmin/60 + $X_mindec/60000);
        my $tmp_y = sprintf("%.5f", $Y_deg + $Y_degmin/60 + $Y_mindec/60000);
        $tmp_x =~ s/\./$Des/;
        $tmp_y =~ s/\./$Des/;
        ($NS eq "S") && ($tmp_y = 0-$tmp_y);
        ($EW eq "W") && ($tmp_x = 0-$tmp_x);
        print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $tmp_x, $tmp_y, $Alt);
        # }}}
    } elsif (/^(@)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(__________________________________________)/) {
        # @020721221336__________________________________________ {{{
        my ($Alfa,   $Year,   $Month, $Day, $Hour, $Min, $Sec, $Rest) =
           (   $1, $2+2000,       $3,   $4,    $5,   $6,   $7,    $8);
        print("\n") unless ($Opt{'output-format'} =~ /^(clean|xgraph|gpstrans|gpx|xml)$/);
        $found_move = 1;
        # }}}
    } elsif (/^xmaplog /) {
        print("\n") unless ($Opt{'output-format'} =~ /^(clean|xgraph|gpstrans|gpx|xml)$/);
    } elsif (/^$/) {
        print("\n") unless ($Opt{'output-format'} =~ /^(clean|xgraph|gpstrans|gpx|xml)$/);
    } else {
        unless ($Opt{'output-format'} =~ /^(clean|xgraph|gpstrans|gpx|xml)$/) {
            print("# $_");
            chomp;
            $Opt{'verbose'} && warn("Line $.: Unknown: \"$_\"\n");
        }
    }
    # }}}
}

# Print possible footer {{{
if ($Opt{'output-format'} eq "gpx") {
    print(<<END);
$Spc$Spc$Spc$Spc</trkseg>
$Spc$Spc</trk>
</gpx>
END
} elsif ($Opt{'output-format'} eq "ps") {
    print(<<END);
*U
%%Trailer
%%EOF
END
} elsif ($Opt{'output-format'} eq "svg") {
    print("\"/>\n</svg>\n");
} elsif ($Opt{'output-format'} eq "xml") {
  print("</gpslog>\n");
}
# }}}

exit(0);

sub read_xmlfile {
    my $Txt = join("", @_);
    # FIXME: The sequential stuff here is probably bad, but easy.
    $Txt =~ s#(<gpx\b.*?>.*?</gpx>)#print_gpx($1)#gse;
    $Txt =~ s#(<gps\b.*?>.*?</gps>)#print_xml_gps($1)#gse;
}

sub print_gpx {
    # {{{
    my $Orig = shift;
    my $Str = $Orig;
    D("print_xml_gps(\"$Orig\")\n");
    my ($Year,  $Mon,  $Day, $Hour,  $Min,  $Sec, $Dsec) =
       ($Udef, $Udef, $Udef, $Udef, $Udef, $Udef, $Udef);
    my ($Pos_X, $Pos_Y, $Pos_Z,  $Alt) =
       ( $Udef,  $Udef,  $Udef, $Udef);
    $Str =~
    s{
        <trk\b(.*?)>(.*?)</trk>
    }
    {
        my $el_trk = $2;
        $el_trk =~
        s{
            <trkseg\b(.*?)>(.*?)</trkseg>
        }
        {
            my $el_trkseg = $2;
            $el_trkseg =~
            s{
                <trkpt\b(.*?)>(.*?)</trkpt>
            }
            {
                my ($attr_trkpt, $el_trkpt) =
                   (         $1,        $2);
                ($attr_trkpt =~ /\blon="(.*?)"/) && ($Pos_X = $1);
                ($attr_trkpt =~ /\blat="(.*?)"/) && ($Pos_Y = $1);
                ($el_trkpt   =~ m#<ele\b.*?>(.*?)</ele>#) && ($Pos_Z = $1);
                if ($Str =~ m#<time>(\d\d\d\d)-?(\d\d)-?(\d\d)T(\d\d):?(\d\d):?(\d\d)\.?(\d*?)Z</time>#) {
                    ($Year, $Mon, $Day, $Hour, $Min, $Sec, $Dsec) =
                    (   $1,   $2,   $3,    $4,   $5,   $6,    $7);
                }
                print_entry($Year, $Mon, $Day, $Hour, $Min, $Sec, $Pos_X, $Pos_Y, $Pos_Z);
            }gsex;
            $found_move = 1;
        }gsex;
        $found_move = 1;
    }gsex;
    # }}}
}

sub print_xml_gps {
    # {{{
    my $Orig = shift;
    my $Str = $Orig;
    D("print_xml_gps(\"$Orig\")\n");
    my ($Year, $Mon, $Day, $Hour, $Min, $Sec, $Dsec);
    my ($Pos_X, $Pos_Y, $Pos_Z, $Alt);
    if ($Str =~ m#<date>(\d\d\d\d)-?(\d\d)-?(\d\d)T(\d\d):?(\d\d):?(\d\d)\.?(\d*?)Z</date>#) {
        ($Year, $Mon, $Day, $Hour, $Min, $Sec, $Dsec) =
        (   $1,   $2,   $3,    $4,   $5,   $6,    $7);
    }
    if ($Str =~ m#<pos>(.*?)</pos>#s) {
        my $Txt = $1;
        ($Txt =~ m#<x\b.*?>(.*?)</x>#) && ($Pos_X = $1);
        ($Txt =~ m#<y\b.*?>(.*?)</y>#) && ($Pos_Y = $1);
        ($Txt =~ m#<z\b.*?>(.*?)</z>#) && ($Pos_Z = $1);
    }
    defined($Pos_X) || ($Pos_X = "");
    defined($Pos_Y) || ($Pos_Y = "");
    defined($Pos_Z) || ($Pos_Z = "");
    print_entry($Year, $Mon, $Day, $Hour, $Min, $Sec, $Pos_X, $Pos_Y, $Pos_Z);
    # }}}
}

sub print_entry {
    # Print a GPS entry with time, latitude, longitude and altitude in 
    # various formats
    # {{{
    my ($Year, $Month, $Day, $Hour, $Min, $Sec, $Lon, $Lat, $Alt) = @_;
    D("print_entry(\"" . join("\", \"", @_) . "\");");
    my $ep_time = timegm_nocheck($Sec, $Min, $Hour, $Day, $Month-1, $Year);
    $Year  = sprintf("%04u", $Year);
    $Month = sprintf("%02u", $Month);
    $Day   = sprintf("%02u", $Day);
    $Hour  = sprintf("%02u", $Hour);
    $Min   = sprintf("%02u", $Min);
    $Sec   = sprintf("%02u", $Sec);
    my $pause_len = 0;
    my $do_print = 1;
    my $Line = "";
    if ($Opt{'output-format'} eq "ps") {
        $Lon *= 100;
        $Lat *= 100;
    }
    if ($Opt{'skip-dups'} && ($Lon eq $last_lon) && ($Lat eq $last_lat) && ($Alt eq $last_alt)) {
        if ($in_dupskip) {
            $do_print = 0;
        } else {
            $do_print = 1;
        }
        $in_dupskip = 1;
    } else {
            $do_print = 1;
            $in_dupskip && print($last_line);
            $in_dupskip = 0;
    }

    if ($Opt{'create-breaks'} && $ep_time-$last_time > $PAUSE_LIMIT && $last_time) {
        $pause_len = $ep_time-$last_time;
    }

    if ($pause_len && ($Opt{'output-format'} !~ /^(clean|xgraph|gpstrans|gpx|xml|svg|ygraph)$/)) {
        printf("# Pause: %s\n# move\n", sec_to_readable($ep_time-$last_time));
    }

    if ($do_print) {
        # Valid data was found, send to stdout {{{
        unless ($first_time) {
            $first_time = $ep_time;
        }
        if ($Opt{'double-y-scale'}) {
            $Lat *= 2;
        }
        if ($Opt{'output-format'} eq "xgraph") {
            $pause_len && ($Line = "move ");
            ($Line .= "$Lon $Lat\n");
        } elsif($Opt{'output-format'} eq "gpstrans") {
            my ($gpt_lat, $gpt_lon) = (ddd_to_dms($Lat), ddd_to_dms($Lon));
            $Line = "T\t$Month/$Day/$Year $Hour:$Min:$Sec\t$gpt_lat\t$gpt_lon\n";
        } elsif($Opt{'output-format'} eq "gpx") {
            $Line = join("",
                            "$Spc$Spc$Spc$Spc$Spc$Spc<trkpt lat=\"$Lat\" lon=\"$Lon\">$Spc",
                            ($Alt eq $Udef) ? "" : "<ele>$Alt</ele>$Spc",
                            "<time>$Year-$Month-${Day}T$Hour:$Min:${Sec}Z</time>$Spc",
                            "</trkpt>\n"
                    );
        } elsif ($Opt{'output-format'} eq "clean") {
            $pause_len && ($Line = "\n");
            ($Line .= "$Lon\t$Lat\t$Alt\n");
        } elsif ($Opt{'output-format'} eq "ps") {
            $Line = ($pause_len ? "f\n$Lon $Lat m\n" : "$Lon $Lat l\n");
        } elsif ($Opt{'output-format'} eq "svg") {
            $Line .= (
                ($last_lon == 1000) || $pause_len
                    ? <<END
$svg_start_thing<path
  stroke="blue"
  stroke-width="0.001"
  fill="none"
  d="
M $Lon $Lat
END
                    : "L $Lon $Lat\n"
            );
        } elsif ($Opt{'output-format'} eq "xml") {
            $Line = join("",
                         "<gps>$Spc",
                             "<date>$Year-$Month-${Day}T$Hour:$Min:${Sec}Z</date>$Spc",
                             "<pos> ",
                                 (length($Lon)) ? "<x>$Lon</x>$Spc" : "",
                                 (length($Lat)) ? "<y>$Lat</y>$Spc" : "",
                                 ($Alt eq $Udef) ? "" : "<z>$Alt</z>$Spc",
                             "</pos> ",
                         "</gps>\n"
                    );
        } elsif ($Opt{'output-format'} eq "ygraph") {
            my $Time = ($ep_time - $first_time) * 1;
            $Line = "\"Time = $Time.0\n$Lon $Lat\n\n";
        } else {
            # Default format used by the author. Yes, the Universe 
            # evolves around him. ☺
            # Seriously, up to "gptrans_conv,v 1.11 2003/08/03 02:35:51 
            # sunny" (r561) the script was only used by myself, and I 
            # found this format was the easiest to live with — Perl 
            # scripts and shell utilities made conversion pretty 
            # painless. If GPX or something other useful is implemented, 
            # that will be the default.
            # {{{
            $Lon =~ s/\./$Des/;
            $Lat =~ s/\./$Des/;
            # $do_print || print("skipping ");
            $Line = join("\t",
                $Opt{'epoch'} ? $ep_time : ($Opt{'short-date'} ? "${Year}${Month}${Day}T${Hour}${Min}${Sec}Z" : "$Year-$Month-$Day $Hour:$Min:$Sec"),
                $Lon, # X-axis
                $Lat, # Y-axis
                $Alt, # Altitude
                "\n"
            );
            # }}}
        }
        # }}}
    }

    if (!$last_time && $Opt{'output-format'} eq "ps") {
        print("$Lon $Lat m\n");
    }

    if ($do_print) {
        if ($found_move) {
            (!$pause_len && ($Opt{'output-format'} eq "xgraph")) && ($Line = "move $Line");
            ($Opt{'output-format'} eq "clean") && (print("\n"));
            if ($Opt{'output-format'} eq "gpx") {
                print("$Spc$Spc$Spc$Spc</trkseg>\n$Spc$Spc$Spc$Spc<trkseg>\n");
            }
            $found_move = 0;
        }
        print($Line);
    }
    $last_time = $ep_time;
    $last_lon  = $Lon;
    $last_lat  = $Lat;
    $last_alt  = $Alt;
    $last_line = $Line;
    $svg_start_thing = "\"/>\n";
    # }}}
}

sub sec_to_string {
    # Convert seconds since 1970 to "yyyy-mm-dd hh:mm:ss" with optional 
    # separator
    # {{{
    my ($Seconds, $Sep) = @_;
    defined($Sep) || ($Sep = " ");
    my @TA = gmtime($Seconds);
    my($DateString) = sprintf("%04u-%02u-%02u%s%02u:%02u:%02u", $TA[5]+1900, $TA[4]+1, $TA[3], $Sep, $TA[2], $TA[1], $TA[0]);
    return($DateString);
    # }}}
}

sub sec_to_readable {
    # Convert seconds since 1970 to human-readable format (d:hh:mm:ss)
    # {{{
    my $secs = shift;
    D("sec_to_readable(\"$secs\")\n");
    my ($Day, $Hour, $Min, $Sec) =
       (   0,     0,    0,    0);

    $Day = int($secs/86400);
    $secs -= $Day * 86400;

    $Hour = int($secs/3600);
    $secs -= $Hour * 3600;

    $Min = int($secs/60);
    $secs -= $Min * 60;

    $Sec = $secs;

    return(sprintf("%u:%02u:%02u:%02u", $Day, $Hour, $Min, $Sec));
    # }}}
}

sub ps_header {
    # Send a Postscript header to stdout {{{
    my ($bl_x, $bl_y, $br_x, $br_y) = @_;
    my $Date = sec_to_string(time);
    return(<<END);
%!PS-Adobe-3.0 EPSF-3.0
%%Creator: $rcs_id
%%Title:
%%CreationDate: $Date
%%BoundingBox: $bl_x $bl_y $br_x $br_y
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
/bd { bind def } bind def
/incompound false def
/m { moveto } bd
/l { lineto } bd
/c { curveto } bd
/F { incompound not {fill} if } bd
/f { closepath F } bd
/S { stroke } bd
/*u { /incompound true def } bd
/*U { /incompound false def f} bd
/k { setcmykcolor } bd
/K { k } bd
%%EndProlog
%%BeginSetup
%%EndSetup
END
    # }}}
}

sub ddd_to_dms {
    # Convert floating-point degrees into D°M'S.S" (ISO-8859-1). 
    # Necessary for import into GPSman. Based on toDMS() from 
    # gpstrans-0.39 to ensure compatibility.
    # {{{
    my $ddd = shift;
    my $Neg = 0;
    my ($Hour, $Min, $Sec) =
       (    0,    0,    0);
    my $Retval = "";

    if ($ddd < 0.0) {
        $ddd = 0 - $ddd;
        $Neg = 1;
    }
    $Hour = int($ddd);
    $ddd = ($ddd - $Hour) * 60.0;
    $Min = int($ddd);
    $Sec = ($ddd - $Min) * 60.0;

    if ($Sec > 59.5) {
        $Sec = 0.0;
        $Min += 1.0;
    }
    if ($Min > 59.5) {
        $Min = 0.0;
        $Hour += 1.0;
    }
    if ($Neg) {
        $Hour = 0 - $Hour;
    }
    D("Neg = $Neg , D = $Hour , M = $Min , S = $Sec\n");
    $Retval = sprintf("%s%.0f\xB0%02.0f'%04.1f\"", $Neg ? "-" : "", $Hour, $Min, $Sec);
    return $Retval;
    # }}}
}

sub usage {
    # Send the help message to stdout {{{
    my $Retval = shift;
    my ($xml_start, $xml_end)  =
       (        "",       "");

    if ($Opt{'xml'}) {
        $xml_start = <<END;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4//EN" "http://docbook.org/xml/4.3/docbookx.dtd">
<article>
  <screen>
END
        $xml_end = <<END;
</screen>
</article>
END
    }
    my $Txt = <<END;
$rcs_id

Usage: $progname [options] [file [files [...]]]
       $progname -u [file [files [...]]]

Options:

  -c, --comment-out-dups
    Use comma instead of period as decimal point (For Gnumeric etc).
  -d, --skip-dups
    Skip duplicated coordinates, only print first and last.
  -e, --epoch
    Use seconds since 1970-01-01 00:00:00 GMT as date format.
  -h, --help
    Show this help.
  -n x, --undefined x
    Use x as undefined value. Default: "$Udef".
  -o x, --output-format x
    Use output format x:
      clean
      gpstrans
      gpx (Not complete)
      ps (Unfinished)
      svg (Unfinished)
      xgraph
      xml
      ygraph
  -s, --short-date
    Use short date format.
  -t, --create-breaks
    Create breaks in track between points with a difference more than 
    $PAUSE_LIMIT seconds.
  -u, --comment-out-dups
    Comment out following data with identical position values, only 
    print first entry.
  -v, --verbose
    Verbose, warn about unknown lines.
  -w, strip-whitespace
    Strip all unnecessary whitespace.
  -x, --xml
    Create XML output.
  -y, --double-y-scale
    Double Y scale to get it right in gnuplot.
  --debug
    Print debugging messages.
END
    printf("%s%s%s",
        $xml_start,
        $Opt{'xml'} ? txt_to_xml($Txt) : "\n$Txt\n",
        $xml_end
    );
    exit($Retval);
    # }}}
}

sub D {
    # {{{
    $Debug || return;
    my @call_info = caller;
    chomp(my $Txt = shift);
    my $File = $call_info[1];
    $File =~ s#\\#/#g;
    $File =~ s#^.*/(.*?)$#$1#;
    if ($Opt{'xml'}) {
        printf(STDERR "<debug> <pid>%s</pid> <file>%s</file> <line>%s</line> <msg>%s</msg> </debug>\n",
            txt_to_xml($$),
            txt_to_xml($File),
            txt_to_xml($call_info[2]),
            txt_to_xml($Txt)
        );
    } else {
        print(STDERR "$File:$call_info[2] $$ $Txt\n");
    }
    return("");
    # }}}
} # D()

sub txt_to_xml {
    # Return a XML-safe version of a string {{{
    my $Txt = shift;

    $Txt =~ s/&/&amp;/gs;
    $Txt =~ s/</&lt;/gs;
    $Txt =~ s/>/&gt;/gs;
    return($Txt);
    # }}}
} # txt_to_xml()

__END__

# Plain Old Documentation (POD) {{{

=pod

=head1 NAME

gptrans_conv

=head1 REVISION

$Id$

=head1 SYNOPSIS

B<gptrans_conv> [OPTION]... [FILE]...

B<gptrans_conv> -u [OPTION]... [FILE]...

=head1 DESCRIPTION

Converts between various GPS formats.

=head1 OPTIONS

=over 4

=item B<-c>, B<--comment-out-dups>

Use comma instead of period as decimal point (For Gnumeric etc).

=item B<-d>, B<--skip-dups>

Skip duplicated coordinates, only print first and last.

=item B<-e>, B<--epoch>

Use seconds since 1970-01-01 00:00:00 GMT as date format.

=item B<-h>, B<--help>

Show this help.

=item B<-n x>, B<--undefined x>

Use x as undefined value.

=item B<-o x>, B<--output-format x>

Use output format x:

=over 4

=over 4

=item clean

=item gpstrans

=item gpx (Not complete)

=item ps (Unfinished)

=item svg (Unfinished)

=item xgraph

=item xml

=item ygraph

=back

=back

Z<>

=item B<-s>, B<--short-date>

Use short date format.

=item B<-t>, B<--create-breaks>

Create breaks in track between points with a difference more than the 
number of seconds specified by the C<$PAUSE_LIMIT> variable.

=item B<-u>, B<--comment-out-dups>

Comment out following data with identical position values, only print 
first entry.

=item B<-v>, B<--verbose>

Verbose, warn about unknown lines.

=item B<-w>, B<strip-whitespace>

Strip all unnecessary whitespace.

=item B<-x>, B<--xml>

Create XML output.

=item B<-y>, B<--double-y-scale>

Double Y scale to get it right in gnuplot.

=item B<-h>, B<--help>

Print a brief help summary.

=item B<-x>, B<--xml>

Create XML output.

=item B<--debug>

Print debugging messages.

=back

=head1 BUGS

Pretty incomplete in some areas. Some of the source formats are 
undocumented and thus incomplete. Some functionality is not working 
properly, for example the Postscript output.

=head1 AUTHOR

Made by Øyvind A. Holm S<E<lt>sunny _AT_ sunbase.orgE<gt>>.

=head1 COPYRIGHT

Copyleft © Øyvind A. Holm &lt;sunny@sunbase.org&gt;
This is free software; see the file F<COPYING> for legalese stuff.

=head1 LICENCE

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2 of the License, or (at your 
option) any later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=head1 SEE ALSO

=cut

# }}}

# vim: set fenc=UTF-8 ft=perl fdm=marker ts=4 sw=4 sts=4 et fo+=w :
# End of file $Id$
