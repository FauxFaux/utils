#!/usr/bin/perl -w

# $Id: gptrans_conv,v 1.9 2003/07/15 12:05:26 sunny Exp $
# Konverterer mellom diverse GPS-formater
# Laget av Øyvind A. Holm — sunny@sunbase.org
# Lisens: GNU GPL

use strict;
use utf8;
use Getopt::Std;
use Time::Local qw { timegm_nocheck };

my $rcs_str = '$Id: gptrans_conv,v 1.9 2003/07/15 12:05:26 sunny Exp $';

our ($opt_c, $opt_d, $opt_e, $opt_h, $opt_o, $opt_s, $opt_t, $opt_u) =
    (     0,      0,      0,      0,     "",      0,      0,      0);
getopts('cdeho:stu');

$| = 1;

if ($opt_h) {
	# {{{
	print(<<END);

Syntax: gptrans_conv [options] [filer [...]]

  -c    Bruk komma istedenfor punktum som desimaltegn
  -d    Skipp duplikat-koordinater, skriv bare første og siste
  -e    «epoch»-format på datoen
  -h    Hjælp mæ
  -o x  Bruk outputformatet x:
          clean
          ps (Uferdig)
          xgraph
  -s    Kort («Short») format på datoen
  -t    Lag skiller mellom tidspunkter med forskjell på mer enn fem minutter
  -u    Kommenter ut data som mangler mottak

END
	exit(0);
	# }}}
}

my $Des = $opt_c ? "," : ".";
my $in_dupskip = 0; # Er 1 hvis vi holder på med ignorering av duplikater
my $found_move = 0; # Settes til 1 hvis en /^# move$/ blir funnet.
my $last_time = 0;
my ($last_lat, $last_lon, $last_alt, $last_line) = (1000, 1000, 100000, ""); # Vi kan jo teoretisk sett være i Greenwich eller på ekvator

# Kunne vært et eget script på grunn av at det gjør sine helt egne greier, men like greit å samle det på en plass.
# FIXME: Fjerner ikke første duplikatentryen.
if ($opt_u) {
	# {{{
	my ($start_date, $end_date, $found_dup) = ("", "", 0);
	my @Dup = ();
	while (<>) {
		if (m#^1 (\S+) (\S+) (\S+) (\S+) (\d\d)/(\d\d)/(\d\d\d\d) (\d\d):(\d\d):(\d\d)#) {
			my ($lon_val, $lat_val, $Speed, $Unkn, $Month, $Day, $Year, $Hour, $Min, $Sec) = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10);
			if (($lon_val eq $last_lon) && ($lat_val eq $last_lat)) {
				unless ($found_dup) {
					$start_date = "$Year$Month${Day}T$Hour$Min$Sec";
					@Dup = ();
					$found_dup = 1;
				}
				push(@Dup, "# $_");
				$end_date = "$Year$Month${Day}T$Hour$Min$Sec";
			} else {
				if ($found_dup) {
					print("# $start_date-$end_date: CO: Uten mottak \x7B\x7B\x7B\n");
					for (@Dup) {
						print($_);
					}
					print("# $start_date-$end_date: CO: Uten mottak \x7D\x7D\x7D\n# move\n$_");
					$found_dup = 0;
				} else {
					print($_);
				}
			}
			$last_lon = $lon_val;
			$last_lat = $lat_val;
		} else {
			if ($found_dup) {
				push(@Dup, $_);
			} else {
				print($_);
			}
		}
	}
	if ($found_dup) {
		print("# $start_date-$end_date: CO: Uten mottak \x7B\x7B\x7B\n");
		for (@Dup) {
			print($_);
		}
		print("# $start_date-$end_date: CO: Uten mottak \x7D\x7D\x7D\n# move\n");
		$found_dup = 0;
	}
	exit(0);
	# }}}
}

if ($opt_o eq "ps") {
	print(ps_header(532, 6034, 533, 6040));
	print("*u\n");
}

while (<>) {
	my $bck_line = $_;
	if (/^# Pause: /) {
	} elsif (/^# move$/) {
		$found_move = 1;
	} elsif (/^#/) {
		print;
	} elsif (m#^(\d+)\t([0-9\.\-,?]+)\t([0-9\.\-,?]+)\t([+\-\d?])#) {
		# Mitt format, ep-stil {{{
		my ($ep_time, $lat_val, $lon_val, $Alt) = ($1, $2, $3, $4, $5, $6, $7, $8, $9);
		my ($Sec, $Min, $Hour, $Day, $Month, $Year, $Wday, $Yday) = gmtime($ep_time);
		$Month++; # Urgh Ⅰ
		$Year += 1900; # Urgh Ⅱ
		print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $lat_val, $lon_val, "?");
		# }}}
	} elsif (m#^(\d\d\d\d)-?(\d\d)-?(\d\d)[T ](\d\d):?(\d\d):?(\d\d)Z?\t([0-9\.\-,?]+)\t([0-9\.\-,?]+)\t([+\-\d?])#) {
		# Mitt format, lettlest {{{
		my ($Year, $Month, $Day, $Hour, $Min, $Sec, $lat_val, $lon_val, $Alt) = ($1, $2, $3, $4, $5, $6, $7, $8, $9);
		print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $lat_val, $lon_val, "?");
		# }}}
	} elsif (m#^T\t(\d\d)/(\d\d)/(\d\d\d\d) (\d\d):(\d\d):(\d\d)\t(.+)\xB0(.+)'(.+)"\t(.+)\xB0(.+)'(.+)"#) {
		# T	09/01/2002 11:51:26	60°23'36.3"	5°19'35.9" {{{
		my ($Month, $Day, $Year, $Hour, $Min, $Sec, $lon_d, $lon_m, $lon_s, $lat_d, $lat_m, $lat_s) = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12);
		my $lon_val = sprintf("%.5f", 1*($lon_d+($lon_m/60)+($lon_s/3600)));
		my $lat_val = sprintf("%.5f", $lat_d+($lat_m/60)+($lat_s/3600));
		print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $lat_val, $lon_val, "?");
		# }}}
	} elsif (m#^1 (\S+) (\S+) (\S+) (\S+) (\d\d)/(\d\d)/(\d\d\d\d) (\d\d):(\d\d):(\d\d)#) {
		# 1 60.3938222 5.3238754 17.3 0 09/01/2002 14:18:23 {{{
		my ($lon_val, $lat_val, $Speed, $Unkn, $Month, $Day, $Year, $Hour, $Min, $Sec) = ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10);
		print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $lat_val, $lon_val, "?");
		# }}}
	} elsif (/^
		# @020721221336N6048353E00701826S015-00001E4859N1673U0000 {{{
			# Regexp {{{
			(@) # @
			(\d\d) # År
			(\d\d) # Måned
			(\d\d) # Dag
			(\d\d) # Timer
			(\d\d) # Minutter
			(\d\d) # Sekunder
			(.) # N|S
			(..) # Grad
			(..) # Gradminutt
			(\d\d\d) # Gradminuttdesimaler
			(.) # E|W
			(\d\d\d) # Grader
			(\d\d) # Gradminutt
			(\d\d\d) # Desimaler gradminutt
			(....) # Nøyaktighet
			(......) # Høyde
			(...............)
			# }}}
			/x) {
		my ($Alfa,
		$Year, $Month, $Day, $Hour, $Min, $Sec,
		$NS, $Y_deg, $Y_degmin, $Y_mindec,
		$EW, $X_deg, $X_degmin, $X_mindec,
		$Accur, $Alt,
		$Rest) =
		($1, $2+2000, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18);
		my $ep_time = timegm_nocheck($Sec, $Min, $Hour, $Day, $Month-1, $Year);
		$last_time = $ep_time;
		my $tmp_x = sprintf("%.5f", $X_deg + $X_degmin/60 + $X_mindec/60000);
		my $tmp_y = sprintf("%.5f", $Y_deg + $Y_degmin/60 + $Y_mindec/60000);
		$tmp_x =~ s/\./$Des/;
		$tmp_y =~ s/\./$Des/;
		print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, $tmp_x, $tmp_y, $Alt);
		# }}}
	} elsif (/^(@)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(__________________________________________)/) {
		# @020721221336__________________________________________ {{{
		my ($Alfa,
		$Year, $Month, $Day, $Hour, $Min, $Sec,
		$Rest) =
		($1, $2+2000, $3, $4, $5, $6, $7, $8);
		print("\n") unless ($opt_o eq "xgraph");
		$found_move = 1;
		# print_entry($Year, $Month, $Day, $Hour, $Min, $Sec, "?", "?", "?");
		# }}}
	} elsif (/^xmaplog /) {
		print("\n") unless ($opt_o eq "xgraph");
	} elsif (/^$/) {
		print("\n") unless ($opt_o eq "xgraph");
	} else {
		print("# $_");
		chomp;
		warn("Linje $.: Ukjent: \"$_\"\n");
	}
}

if ($opt_o eq "ps") {
	print(<<END);
*U
%%Trailer
%%EOF
END
}

sub print_entry {
	# {{{
	my ($Year, $Month, $Day, $Hour, $Min, $Sec, $Lat, $Lon, $Alt) = @_;
	my $ep_time = timegm_nocheck($Sec, $Min, $Hour, $Day, $Month-1, $Year);
	$Year = sprintf("%04u", $Year);
	$Month = sprintf("%02u", $Month);
	$Day = sprintf("%02u", $Day);
	$Hour = sprintf("%02u", $Hour);
	$Min = sprintf("%02u", $Min);
	$Sec = sprintf("%02u", $Sec);
	my $pause_len = 0;
	my $do_print = 1;
	my $Line = "";
	if ($opt_o eq "ps") {
		$Lat *= 100;
		$Lon *= 100;
	}
	if ($opt_d && ($Lat eq $last_lat) && ($Lon eq $last_lon) && ($Alt eq $last_alt)) {
		if ($in_dupskip) {
			$do_print = 0;
		} else {
			$do_print = 1;
		}
		$in_dupskip = 1;
	} else {
			$do_print = 1;
			$in_dupskip && print($last_line);
			$in_dupskip = 0;
	}

	if ($opt_t && $ep_time-$last_time > 300 && $last_time) {
		$pause_len = $ep_time-$last_time;
	}

	if ($pause_len) {
		printf("# Pause: %s\n", Tidsperiode($ep_time-$last_time));
	}

	if ($do_print) {
		if ($opt_o eq "xgraph") {
			$pause_len && ($Line = "move ");
			($Line .= "$Lat $Lon\n");
		} elsif ($opt_o eq "clean") {
			$pause_len && ($Line = "\n");
			($Line .= "$Lat $Lon\n");
		} elsif ($opt_o eq "ps") {
			$Line = ($pause_len ? "f\n$Lat $Lon m\n" : "$Lat $Lon l\n");
		} else {
			$Lat =~ s/\./$Des/;
			$Lon =~ s/\./$Des/;
			# $do_print || print("dropper ");
			$Line = join("\t",
				$opt_e ? $ep_time : ($opt_s ? "${Year}${Month}${Day}T${Hour}${Min}${Sec}Z" : "$Year-$Month-$Day $Hour:$Min:$Sec"),
				$Lat,
				$Lon,
				$Alt,
				"\n");
		}
	}

	if (!$last_time && $opt_o eq "ps") {
		print("$Lat $Lon m\n");
	}

	if ($do_print) {
		if ($found_move) {
			(!$pause_len && ($opt_o eq "xgraph")) && ($Line = "move $Line");
			$found_move = 0;
		}
		print($Line);
	}
	$last_time = $ep_time;
	$last_lat = $Lat;
	$last_lon = $Lon;
	$last_alt = $Alt;
	$last_line = $Line;
	# }}}
}

sub sec_to_string {
	# {{{
	my ($Seconds, $Sep) = @_;
	defined($Sep) || ($Sep = " ");
	my @TA = gmtime($Seconds);
	my($DateString) = sprintf("%04u-%02u-%02u%s%02u:%02u:%02u", $TA[5]+1900, $TA[4]+1, $TA[3], $Sep, $TA[2], $TA[1], $TA[0]);
	return($DateString);
	# }}}
}

sub Tidsperiode {
	# {{{
	my $secs = shift;
	my ($Day, $Hour, $Min, $Sec) = (0, 0, 0, 0);

	$Day = int($secs/86400);
	$secs -= $Day*86400;

	$Hour = int($secs/3600);
	$secs -= $Hour * 3600;

	$Min = int($secs/60);
	$secs -= $Min * 60;

	$Sec = $secs;

	return(($Day ? "$Day dager og " : "") . sprintf("%02u:%02u:%02u", $Hour, $Min, $Sec));
	# }}}
}

sub ps_header {
	# {{{
	my ($bl_x, $bl_y, $br_x, $br_y) = @_;
	my $Date = sec_to_string(time);
	return(<<END);
%!PS-Adobe-3.0 EPSF-3.0
%%Creator: $rcs_str
%%Title:
%%CreationDate: $Date
%%BoundingBox: $bl_x $bl_y $br_x $br_y
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
/bd { bind def } bind def
/incompound false def
/m { moveto } bd
/l { lineto } bd
/c { curveto } bd
/F { incompound not {fill} if } bd
/f { closepath F } bd
/S { stroke } bd
/*u { /incompound true def } bd
/*U { /incompound false def f} bd
/k { setcmykcolor } bd
/K { k } bd
%%EndProlog
%%BeginSetup
%%EndSetup
END
	# }}}
}

# End of file $Id: gptrans_conv,v 1.9 2003/07/15 12:05:26 sunny Exp $
